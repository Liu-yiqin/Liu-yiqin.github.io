<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Unity扩展知识点 | 刘一钦的成长之路</title><meta name="keywords" content="Unity扩展知识点"><meta name="author" content="刘一钦"><meta name="copyright" content="刘一钦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Unity扩展知识点 一、使用事件的监听与广播高度解耦合1.1 监听与广播基于的三个脚本文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity扩展知识点">
<meta property="og:url" content="http://example.com/2021/03/01/UnityKnowledge/index.html">
<meta property="og:site_name" content="刘一钦的成长之路">
<meta property="og:description" content="Unity扩展知识点 一、使用事件的监听与广播高度解耦合1.1 监听与广播基于的三个脚本文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210803144953.png">
<meta property="article:published_time" content="2021-02-28T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-07T11:43:47.887Z">
<meta property="article:author" content="刘一钦">
<meta property="article:tag" content="Unity扩展知识点">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210803144953.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/03/01/UnityKnowledge/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-07 19:43:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210803144955.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">刘一钦的成长之路</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity扩展知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-28T16:00:00.000Z" title="发表于 2021-03-01 00:00:00">2021-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-07T11:43:47.887Z" title="更新于 2022-03-07 19:43:47">2022-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity扩展知识点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />

<blockquote>
<h1 id="Unity扩展知识点"><a href="#Unity扩展知识点" class="headerlink" title="Unity扩展知识点"></a>Unity扩展知识点</h1></blockquote>
<h2 id="一、使用事件的监听与广播高度解耦合"><a href="#一、使用事件的监听与广播高度解耦合" class="headerlink" title="一、使用事件的监听与广播高度解耦合"></a>一、使用事件的监听与广播高度解耦合</h2><h3 id="1-1-监听与广播基于的三个脚本文件"><a href="#1-1-监听与广播基于的三个脚本文件" class="headerlink" title="1.1 监听与广播基于的三个脚本文件"></a>1.1 监听与广播基于的三个脚本文件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">脚本一：CallBack</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>&gt;(<span class="params">T arg</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>, <span class="title">X</span>&gt;(<span class="params">T arg1, X arg2</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>&gt;(<span class="params">T arg1, X arg2, Y arg3</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt;(<span class="params">T arg1, X arg2, Y arg3, Z arg4</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallBack</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>, <span class="title">W</span>&gt;(<span class="params">T arg1, X arg2, Y arg3, Z arg4, W arg5</span>)</span>;</span><br><span class="line"></span><br><span class="line">脚本二：EventCenter</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventCenter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">Dictionary</span>&lt;<span class="title">EventType</span>, <span class="title">Delegate</span>&gt; m_EventTable</span> = <span class="keyword">new</span> Dictionary&lt;EventType, Delegate&gt;();  <span class="comment">//字典：key是事件码value是委托</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnListenerAdding</span>(<span class="params">EventType eventType,Delegate callBack</span>)  <span class="comment">//检查正在添加的监听能否成功的方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_EventTable.ContainsKey(eventType))  <span class="comment">//字典中的ContainsKey方法：查看字典中是否含有eventType键</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_EventTable.Add(eventType, <span class="literal">null</span>);  <span class="comment">//如果没有此键，则用字典中的Add方法添加一个，键设置为eventType，值为null</span></span><br><span class="line">        &#125;</span><br><span class="line">        Delegate d = m_EventTable[eventType];  <span class="comment">//m_EventTable[eventType]表示取字典m_EventTable键为eventType的值</span></span><br><span class="line">        <span class="keyword">if</span> (d != <span class="literal">null</span> &amp;&amp; d.GetType() != callBack.GetType())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;尝试为事件&#123;0&#125;添加不同类型的委托，当前事件所对应的委托是&#123;1&#125;，要添加的委托类型为&#123;2&#125;&quot;</span>, eventType, d.GetType(), callBack.GetType()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>(<span class="params">EventType eventType,CallBack callBack</span>)  <span class="comment">//无参的添加监听的方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerAdding(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack)m_EventTable[eventType] + callBack;  <span class="comment">//多播委托：给原始的委托添加一个我们需要的callback委托</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思路：先判断事件码中有无此键，若无则添加一个。若有则判断此键对应的委托类型是否与callback类型一致，若一致就把需要添加的委托添加上去，否则throw。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//单个参数的添加监听的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,CallBack&lt;T&gt; callBack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerAdding(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个参数的添加监听的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>,<span class="title">X</span>&gt;(<span class="params">EventType eventType, CallBack&lt;T,X&gt; callBack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerAdding(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T,X&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三个参数的添加监听的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>&gt;(<span class="params">EventType eventType, CallBack&lt;T, X, Y&gt; callBack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerAdding(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T, X, Y&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//四个参数的添加监听的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt;(<span class="params">EventType eventType, CallBack&lt;T, X, Y, Z&gt; callBack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerAdding(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T, X, Y, Z&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//五个参数的添加监听的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>, <span class="title">W</span>&gt;(<span class="params">EventType eventType, CallBack&lt;T, X, Y, Z, W&gt; callBack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerAdding(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T, X, Y, Z, W&gt;)m_EventTable[eventType] + callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnListenerRemoving</span>(<span class="params">EventType eventType,Delegate callBack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_EventTable.ContainsKey(eventType))  <span class="comment">//如果有此事件码则判断：它的委托是否为空、它的委托类型是否为CallBack</span></span><br><span class="line">        &#123;</span><br><span class="line">            Delegate d = m_EventTable[eventType];</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误；事件&#123;0&#125;没有对应的委托&quot;</span>, eventType));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d.GetType() != callBack.GetType())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误；尝试为事件&#123;0&#125;移除不同类型的委托，当前委托类型为&#123;1&#125;，要移除的委托类型为&#123;2&#125;&quot;</span>, eventType, d.GetType(), callBack.GetType()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;移除监听错误；没有事件码&#123;0&#125;&quot;</span>, eventType));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnListenerRemoved</span>(<span class="params">EventType eventType,Delegate callBack</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_EventTable[eventType] == <span class="literal">null</span>)  <span class="comment">//如果此事件码已经不包含委托，就把它从表里移除</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_EventTable.Remove(eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>(<span class="params">EventType eventType,CallBack callBack</span>)  <span class="comment">//无参的移除监听的方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerRemoving(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack)m_EventTable[eventType] - callBack;</span><br><span class="line">        OnListenerRemoved(eventType, callBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType, CallBack&lt;T&gt; callBack</span>)  <span class="comment">//单个参数的移除监听的方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerRemoving(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T&gt;)m_EventTable[eventType] - callBack;</span><br><span class="line">        OnListenerRemoved(eventType, callBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>,<span class="title">X</span>&gt;(<span class="params">EventType eventType, CallBack&lt;T,X&gt; callBack</span>)  <span class="comment">//两个参数的移除监听的方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerRemoving(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T,X&gt;)m_EventTable[eventType] - callBack;</span><br><span class="line">        OnListenerRemoved(eventType, callBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>&gt;(<span class="params">EventType eventType, CallBack&lt;T, X, Y&gt; callBack</span>)  <span class="comment">//三个参数的移除监听的方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerRemoving(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T, X, Y&gt;)m_EventTable[eventType] - callBack;</span><br><span class="line">        OnListenerRemoved(eventType, callBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt;(<span class="params">EventType eventType, CallBack&lt;T, X, Y, Z&gt; callBack</span>)  <span class="comment">//四个参数的移除监听的方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerRemoving(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T, X, Y, Z&gt;)m_EventTable[eventType] - callBack;</span><br><span class="line">        OnListenerRemoved(eventType, callBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveListener</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>, <span class="title">W</span>&gt;(<span class="params">EventType eventType, CallBack&lt;T, X, Y, Z, W&gt; callBack</span>)  <span class="comment">//五个参数的移除监听的方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        OnListenerRemoving(eventType, callBack);</span><br><span class="line">        m_EventTable[eventType] = (CallBack&lt;T, X, Y, Z, W&gt;)m_EventTable[eventType] - callBack;</span><br><span class="line">        OnListenerRemoved(eventType, callBack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>(<span class="params">EventType eventType</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Delegate d;</span><br><span class="line">        <span class="keyword">if</span> (m_EventTable.TryGetValue(eventType,<span class="keyword">out</span> d))  <span class="comment">//TryGetValue是取键为eventType的值(委托)，out给d</span></span><br><span class="line">        &#123;</span><br><span class="line">            CallBack callBack=d <span class="keyword">as</span> CallBack;  <span class="comment">//as:类型转换关键字，成功d就转换成CallBack，失败就把null赋给callBack</span></span><br><span class="line">            <span class="keyword">if</span> (callBack != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                callBack();  <span class="comment">//如果成功拿到此值，就进行广播</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//如果这个委托值和CallBack不是一个类型就进行throw</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>, eventType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思路：先取出这个m_EventTable的委托值，判断是否为CallBack类型的委托，如果是就广播此委托，如果不是就throw</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>&gt;(<span class="params">EventType eventType,T arg</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Delegate d;</span><br><span class="line">        <span class="keyword">if</span> (m_EventTable.TryGetValue(eventType, <span class="keyword">out</span> d))  </span><br><span class="line">        &#123;</span><br><span class="line">            CallBack&lt;T&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T&gt;;  </span><br><span class="line">            <span class="keyword">if</span> (callBack != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                callBack(arg);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>, eventType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>,<span class="title">X</span>&gt;(<span class="params">EventType eventType, T arg1, X arg2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Delegate d;</span><br><span class="line">        <span class="keyword">if</span> (m_EventTable.TryGetValue(eventType, <span class="keyword">out</span> d))</span><br><span class="line">        &#123;</span><br><span class="line">            CallBack&lt;T,X&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T,X&gt;;</span><br><span class="line">            <span class="keyword">if</span> (callBack != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                callBack(arg1,arg2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>, eventType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>&gt;(<span class="params">EventType eventType, T arg1, X arg2, Y arg3</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Delegate d;</span><br><span class="line">        <span class="keyword">if</span> (m_EventTable.TryGetValue(eventType, <span class="keyword">out</span> d))</span><br><span class="line">        &#123;</span><br><span class="line">            CallBack&lt;T, X, Y&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T, X, Y&gt;;</span><br><span class="line">            <span class="keyword">if</span> (callBack != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                callBack(arg1, arg2, arg3);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>, eventType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt;(<span class="params">EventType eventType, T arg1, X arg2, Y arg3, Z arg4</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Delegate d;</span><br><span class="line">        <span class="keyword">if</span> (m_EventTable.TryGetValue(eventType, <span class="keyword">out</span> d))</span><br><span class="line">        &#123;</span><br><span class="line">            CallBack&lt;T, X, Y, Z&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T, X, Y, Z&gt;;</span><br><span class="line">            <span class="keyword">if</span> (callBack != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                callBack(arg1, arg2, arg3, arg4);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>, eventType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Broadcast</span>&lt;<span class="title">T</span>, <span class="title">X</span>, <span class="title">Y</span>, <span class="title">Z</span>, <span class="title">W</span>&gt;(<span class="params">EventType eventType, T arg1, X arg2, Y arg3, Z arg4, W arg5</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Delegate d;</span><br><span class="line">        <span class="keyword">if</span> (m_EventTable.TryGetValue(eventType, <span class="keyword">out</span> d))</span><br><span class="line">        &#123;</span><br><span class="line">            CallBack&lt;T, X, Y, Z, W&gt; callBack = d <span class="keyword">as</span> CallBack&lt;T, X, Y, Z, W&gt;;</span><br><span class="line">            <span class="keyword">if</span> (callBack != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                callBack(arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;广播事件错误：事件&#123;0&#125;对应的委托具有不同的类型&quot;</span>, eventType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">脚本三：EventType</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EventType  <span class="comment">//存放事件码</span></span><br><span class="line">&#123;</span><br><span class="line">    ShowText,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-文件对监听与广播脚本的调用"><a href="#1-2-文件对监听与广播脚本的调用" class="headerlink" title="1.2 文件对监听与广播脚本的调用"></a>1.2 文件对监听与广播脚本的调用</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">调用脚本的程序一：BtnClick</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BtnClick</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            EventCenter.Broadcast(EventType.ShowText,<span class="string">&quot;你好&quot;</span>,<span class="string">&quot;呀&quot;</span>, <span class="number">1.0f</span>, <span class="number">2</span> ,<span class="number">3</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处的AddListener为UnityEngine类中的一个方法，此方法的参数只有一个委托类型的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处按动按钮显示文本的程序运行流程为：</span></span><br><span class="line">    <span class="comment">//在BtnClick类的Awake方法中为此处的AddListener方法添加一个委托Broadcast，并调用此委托；</span></span><br><span class="line">    <span class="comment">//在ShowText类中执行Awak方法：为ShowText事件码添加Show方法(显示文本)；(这一步怎么调用的？)</span></span><br><span class="line">    <span class="comment">//在Broadcast方法中取字典m_EventTable中键为ShowText的字典值(委托)，并执行此委托方法Show；</span></span><br><span class="line">    <span class="comment">//文本显示。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用脚本的程序二：ShowText</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShowText</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);  <span class="comment">//此处的gameObject指的就是脚本挂接的物体</span></span><br><span class="line">        EventCenter.AddListener&lt;<span class="built_in">string</span>,<span class="built_in">string</span>,<span class="built_in">float</span>,<span class="built_in">int</span>,<span class="built_in">int</span>&gt;(EventType.ShowText, Show);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EventCenter.RemoveListener&lt;<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;(EventType.ShowText, Show);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="built_in">string</span> str, <span class="built_in">string</span> str1,<span class="built_in">float</span> a,<span class="built_in">int</span> b,<span class="built_in">int</span> c</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        GetComponent&lt;Text&gt;().text = str+str1+a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-此方法的利与弊"><a href="#1-3-此方法的利与弊" class="headerlink" title="1.3 此方法的利与弊"></a>1.3 此方法的利与弊</h3><p>利：解决了代码之间的耦合，每个需要执行的功能都只需要监听事件即可。</p>
<p>弊：添加监听的时候必须注意泛型参数和调用的方法参数一致；广播的时候也必须要知道它所监听事件码的泛型参数类型与顺序。</p>
<h2 id="二、协程"><a href="#二、协程" class="headerlink" title="二、协程"></a>二、协程</h2><h3 id="2-1-Time类中的各种方法"><a href="#2-1-Time类中的各种方法" class="headerlink" title="2.1  Time类中的各种方法"></a>2.1  Time类中的各种方法</h3><h4 id="Time-deltaTime"><a href="#Time-deltaTime" class="headerlink" title="Time.deltaTime"></a>Time.deltaTime</h4><p>从最后一帧到当前帧的间隔(以秒为单位)(只读）。</p>
<p><strong>经典的例子</strong></p>
<p>首先看一个经典例子：让一个物体以每秒移动10米，代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    transform.Translate(<span class="number">0</span>,<span class="number">0</span>,Time.delaTime*<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间增量</strong></p>
<p>我们假设游戏运行时，1秒是60帧，可以理解为每秒播放60个画面，而时间增量就可以理解为每一个画面所消耗的时间(即每一帧所消耗的时间)，它是实时变动的且每一帧都在变动。</p>
<p>1秒30帧，那增量时间就是 1/30 秒<br>1秒60帧，那增量时间就是 1/60 秒<br>1秒166帧，那增量时间就是 1/166 秒</p>
<p>这样就保证了上述案例无论帧率是多少，都可以确定1秒移动10米。</p>
<h4 id="Time-time"><a href="#Time-time" class="headerlink" title="Time.time"></a>Time.time</h4><p>此帧开始的时间（游戏时间）（只读）。</p>
<h3 id="2-2-yield关键字"><a href="#2-2-yield关键字" class="headerlink" title="2.2 yield关键字"></a>2.2 yield关键字</h3><p>C#文档的具体描述：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield">yield contextual keyword - C# Reference | Microsoft Docs</a></p>
<p>yield关键字的一般使用：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> &lt;expression&gt;;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>yield return和yield break通常在迭代器中使用，用yield return来返回值，用yield break来结束迭代器。（迭代器中不建议使用return和break）。</li>
<li>迭代器中的yield break相当于普通方法中的return，直接终止方法，不仅仅是终止循环，是终止整个方法。这一点不同于break，break只跳出一层循环，后面的语句仍然执行。而yield break不执行yield break后面的语句。</li>
<li>yield return用来返回一个值，并将迭代器的位置通过状态标识存储起来，下次迭代从该位置继续访问。</li>
</ul>
<h4 id="2-2-1-yield-return实例"><a href="#2-2-1-yield-return实例" class="headerlink" title="2.2.1 yield return实例"></a>2.2.1 yield return实例</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span> &#123; </span><br><span class="line">      <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> item <span class="keyword">in</span> <span class="title">GetNumbers</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function">          Console.<span class="title">WriteLine</span>(<span class="params"><span class="string">&quot;Main process. item = &quot;</span> + item</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetNumbers</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以[0, 1, 2]初始化数列 list</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Initializating...&quot;</span>);</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        list.Add(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次 yield return 返回一个list的数据</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Processing...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Yield called.&quot;</span>);</span><br><span class="line">         <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Initializating...</span><br><span class="line">Processing...</span><br><span class="line">Yield called.</span><br><span class="line">Main process. item = <span class="number">0</span></span><br><span class="line">Yield called.</span><br><span class="line">Main process. item = <span class="number">1</span></span><br><span class="line">Yield called.</span><br><span class="line">Main process. item = <span class="number">2</span></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>示例说明：</p>
<p>以上代码的主函数使用foreach输出GetNumbers()方法的数据。此方法一共有3个数据，调用了三次此函数的处理部分，而初始化部分只调用了一次。</p>
</li>
<li><p>使用方法解析：</p>
<p>这个函数在处理循环时可以每生成一个数据就返回一个数据让主函数进行处理。在单线程的程序中，由于不需要等所有数据都处理好再返回，所以可以减少对内存占用。比如说有3个数据，如果一次性处理好返回，需要占用3个内存单位，而一个个返回，只需要占用1个内存单位。在多线程的处理程序中，还可以加快程序的处理速度。当数据处理以后，主程序可以进行处理，而被调用函数可以继续处理一下个数据。一个经典的应用是Socket，主线程处理对Socket接收到的数据进行处理，而另外一个线程负责读取Socket的内容。当接收的数据量比较大时，两个线程可以加快处理速度。</p>
</li>
</ul>
<h4 id="2-2-2-yield-return的执行顺序"><a href="#2-2-2-yield-return的执行顺序" class="headerlink" title="2.2.2 yield return的执行顺序"></a>2.2.2 yield return的执行顺序</h4><p>下面我们先来看看C#官方文档的两个经典例子：</p>
<p>在第一个例子中，我们展示了如何调用协程和继续并行执行函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IEnumerator coroutine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;Starting &quot;</span> + Time.time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start function WaitAndPrint as a coroutine.</span></span><br><span class="line"></span><br><span class="line">        coroutine = WaitAndPrint(<span class="number">2.0f</span>);</span><br><span class="line">        StartCoroutine(coroutine);</span><br><span class="line">        print(<span class="string">&quot;Before WaitAndPrint Finishes &quot;</span> + Time.time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// every 2 seconds perform the print()</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">WaitAndPrint</span>(<span class="params"><span class="built_in">float</span> waitTime</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">waitTime</span>)</span>;</span><br><span class="line">            print(<span class="string">&quot;WaitAndPrint &quot;</span> + Time.time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// - After 0 seconds, prints &quot;Starting 0.0&quot;</span></span><br><span class="line"><span class="comment">// - After 0 seconds, prints &quot;Before WaitAndPrint Finishes 0.0&quot;</span></span><br><span class="line"><span class="comment">// - After 2 seconds, prints &quot;WaitAndPrint 2.0&quot;</span></span><br></pre></td></tr></table></figure>



<p>在第二个例子中，我们展示了如何调用一个协程并等待它完成执行完成：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;Starting &quot;</span> + Time.time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start function WaitAndPrint as a coroutine. And wait until it is completed.</span></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">WaitAndPrint(<span class="number">2.0f</span></span>))</span>;  <span class="comment">// the same as yield return WaitAndPrint(2.0f);</span></span><br><span class="line">        print(<span class="string">&quot;Done &quot;</span> + Time.time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// suspend execution for waitTime seconds</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">WaitAndPrint</span>(<span class="params"><span class="built_in">float</span> waitTime</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">waitTime</span>)</span>;</span><br><span class="line">        print(<span class="string">&quot;WaitAndPrint &quot;</span> + Time.time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// - After 0 seconds, prints &quot;Starting 0.0&quot;</span></span><br><span class="line"><span class="comment">// - After 2 seconds, prints &quot;WaitAndPrint 2.0&quot;</span></span><br><span class="line"><span class="comment">// - After 2 seconds, prints &quot;Done 2.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>从上面两个例子可以看出以下两点：</p>
<ul>
<li>当方法中开始的协程被暂停时，可以继续执行代码的其它部分直到暂停结束继续完成协程中的代码。</li>
<li><strong>yield return expression 只有表达式完全执行结束才会继续执行后面的代码，就是说当yield return后面跟了一个返回IEnumerator的方法时，只有当IEnumerator迭代完成时才会执行yield return后续的代码。</strong></li>
</ul>
<h4 id="2-2-3-WaitForSeconds方法"><a href="#2-2-3-WaitForSeconds方法" class="headerlink" title="2.2.3 WaitForSeconds方法"></a>2.2.3 WaitForSeconds方法</h4><p>首先，WaitForSeconds方法是WaitForSeconds类的构造器方法，而WaitForSeconds类继承自YieldInstruction基类。 对于Unity 引擎的 YieldInstruction实现，其实就可以看成一个方法，这个方法每帧会实现去 check MoveNext 是否返回 false 。例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">yield</span> retrun <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2f</span></span>)</span>;  </span><br></pre></td></tr></table></figure>

<p>上面这行代码的伪代码实现:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> elapsedTime;  </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> time;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveNext</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        elapesedTime += Time.deltaTime;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(time &lt;= elapsedTime)  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="2-3-foreach原理"><a href="#2-3-foreach原理" class="headerlink" title="2.3 foreach原理"></a>2.3 foreach原理</h3><p>foreach在C#中是实现对类型的遍历，但不是所有类型都可以被foreach遍历。下面以一个最简单的String类型来看看可以被foreach遍历的类具备什么条件：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//more code</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">//more code</span></span><br><span class="line">pubic <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CharEnumerator</span>:<span class="title">ICloneabe</span>,<span class="title">IEnumerator</span>&lt;<span class="title">char</span>&gt;,<span class="title">IEnumerator</span>,<span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">char</span> Current &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">    <span class="comment">//more code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="comment">//more code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出可以被foreach遍历的类必须有适当的公共 MoveNext 方法和公共 Current 属性。</p>
<p>我们自己实现一个可以被foreach遍历的类型：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> cat)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] datas=<span class="keyword">new</span> <span class="built_in">string</span>[]&#123;<span class="string">&quot;波斯猫&quot;</span>,<span class="string">&quot;狸花猫&quot;</span>,<span class="string">&quot;无毛猫&quot;</span>,<span class="string">&quot;虎斑猫&quot;</span>&#125;;  <span class="comment">//我们将数据对象通过GetEnumerator方法作为迭代计数器对象（CatEnumerator）构造函数的参数传递进去，然后迭代计数器对象提供一个属性将这些数据存储起来。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CatEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatEnumerator(datas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CatEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] datas;  <span class="comment">//存储数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CatEnumerator</span>(<span class="params"><span class="built_in">string</span>[] datas</span>)  <span class="comment">//带参构造函数</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.datas=datas;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> index=<span class="number">-1</span>;  <span class="comment">//数组下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">char</span> Current  <span class="comment">//遍历当前元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> datas[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">return</span> index &lt; datas.Length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">波斯猫</span><br><span class="line">狸花猫</span><br><span class="line">无毛猫</span><br><span class="line">虎斑猫</span><br></pre></td></tr></table></figure>

<p>此程序需要注意的三点：</p>
<ul>
<li>GetEnumerator 方法的作用是让 foreach 调用当前需要遍历的类型的迭代计数器对象，该方法的返回类型为用于foreach 遍历的迭代计数器对象；</li>
<li>Current 属性就是当前遍历到的对象；</li>
<li>MoveNext 方法促使迭代计数器对象的计数移动到下一位。</li>
</ul>
<p>以上程序执行的主要步骤如下：</p>
<ol>
<li>foreach进入Cat类调用GetEnumerator方法创建一个迭代计数器对象，并将要遍历的数据传递给迭代计数器对象的构造函数中(此处实例化的对象就为foreach语句遍历的对象)；</li>
<li>迭代计数器对象调用它的 MoveNext 方法将小标递增 1 ，若下标大于数据长度则迭代完成；</li>
<li>MoveNext 方法返回 bool值true或false并返回 Current 属性中存储的数据。</li>
</ol>
<p>总结起来就是<strong>foreach在被迭代的类中获取迭代计数器对象</strong>&gt;&gt;<strong>此对象用自身的MoveNext方法以及Current属性来迭代自身</strong> 。</p>
<h3 id="2-4-迭代器原理"><a href="#2-4-迭代器原理" class="headerlink" title="2.4 迭代器原理"></a>2.4 迭代器原理</h3><h4 id="2-4-1-迭代器初了解"><a href="#2-4-1-迭代器初了解" class="headerlink" title="2.4.1 迭代器初了解"></a>2.4.1 迭代器初了解</h4><p>迭代器模式（iterator pattern），它通过持有迭代状态，追踪当前元素并且识别下一个需要被迭代的元素，从而可以让使用者透过特定的界面巡访容器中的每一个元素。现在来了解一下C#中迭代器的实现原理。</p>
<p>总所周知，迭代器被封装在IEnumerable和IEnumerator这两个接口中（当然，还有它们的泛型形式，要注意的是泛型形式显然是强类型的。且IEnumerator<T>实现了IDisposable接口）。</p>
<ul>
<li>IEnumerable非泛型形式：</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IEnumerable非泛型形式</span></span><br><span class="line">[<span class="meta">ComVisibleAttribute(True)</span>]</span><br><span class="line">[<span class="meta">GuidAttribute(<span class="meta-string">&quot;496B0ABE-   CDEE-11d3-88E8-00902754C43A&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>IEnumerator非泛型形式：</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IEnumerator非泛型形式</span></span><br><span class="line">[<span class="meta">ComVisibleAttribute(true)</span>]</span><br><span class="line">[<span class="meta">GuidAttribute(<span class="meta-string">&quot;496B0ABF-CDEE-11d3-88E8-00902754C43A&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    Object Current &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>IEnumerable泛型形式:</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IEnumerable泛型形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>IEnumerator泛型形式:</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IEnumerator泛型形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IDisposable</span>, <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>; </span><br><span class="line">    Object Current &#123;<span class="keyword">get</span>;&#125; </span><br><span class="line">    T Current &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ComVisibleAttribute(true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IEnumerable接口定义了一个可以获取IEnumerator的方法——GetEnumerator()。</p>
<p>而IEnumerator则在目标序列上实现循环迭代（使用MoveNext()方法，以及Current属性来实现），直到你不再需要任何数据或者没有数据可以被返回。使用这个接口，可以保证我们能够实现常见的foreach循环。</p>
<p><strong>关于两个接口的问题</strong></p>
<p>假如两个不同的迭代器要对同一个序列进行迭代。当然，这种情况很常见，比如我们使用两个嵌套的foreach语句。我们自然希望两者相安无 事，不要互相影响彼此。所以自然而然的，我们需要保证这两个独立的迭代状态能够被正确的保存、处理。这也正是IEnumerator要做的工作。而为了不 违背单一职责原则，不使IEnumerable拥有过多职责从而陷入分工不明的窘境，所以IEnumerable自己并没有实现MoveNext()方 法。</p>
<p><strong>迭代器的执行步骤</strong></p>
<p>以一个例子来直观了解一下迭代器的执行步骤：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Class1</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="function"><span class="built_in">string</span> s <span class="keyword">in</span> <span class="title">GetEnumerableTest</span>(<span class="params"></span>))</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">GetEnumerableTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;begin&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> i.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>捋一下这段代码的执行流程：</p>
<ol>
<li>Main调用GetEnumerableTest()方法；</li>
<li>GetEnumerableTest()方法会为我们创建一个编译器生成的新的类”Class1/’c__Iterator0’”（本例中）的实例。注：此时GetEnumerableTest()方法中，我们自己的代码尚未执行；</li>
<li>Main调用MoveNext()方法；</li>
<li>迭代器开始执行，直到它遇到第一个yield return语句。此时迭代器会获取当前的值是“begin”，并且返回true以告知此时还有数据；</li>
<li>Main使用Current属性以获取数据，并打印出来；</li>
<li>Main再次调用MoveNext()方法；</li>
<li>迭代器继续从上次遇到yield return的地方开始执行，并且和之前一样，直到遇到下一个yield return；</li>
<li>迭代器按照这种方式循环，直到MoveNext()方法返回false，以告知此时已经没有数据了。</li>
</ol>
<p>这个例子还有几个注意点：</p>
<ul>
<li>在第一次调用MoveNext()方法之前，我们自己在GetEnumerableTest中的代码不会执行。</li>
<li>之后调用MoveNext()方法时，会从上次暂停（yield return）的地方开始。</li>
<li>编译器会保证GetEnumerableTest方法中的局部变量能够被保留，换句话说，虽然本例中的i是值类型实例，但是它的值其实是被迭代器 保存在堆上的，这样才能保证每次调用MoveNext时，它是可用的。</li>
</ul>
<h4 id="2-4-2-状态机"><a href="#2-4-2-状态机" class="headerlink" title="2.4.2 状态机"></a>2.4.2 状态机</h4><p>下面我们来看看迭代器的具体实现原理，为方便起见，这个小程序仅仅实现一个按顺序返回0-9这10个数字的功能。</p>
<p><strong>IEnumerator的内部实现</strong></p>
<p>首先，我们定义一个返回IEnumerator的方法TestIterator()。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IEnumerator&lt;T&gt;测试</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> IEnumerator&lt;<span class="built_in">int</span>&gt; <span class="title">TestIterator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们看看反编译之后的代码，探查一下编译器到底为我们做了什么。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Methods 注，此时还没有执行任何我们写的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerator&lt;<span class="built_in">int</span>&gt; <span class="title">TestIterator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> &lt;TestIterator&gt;d__0(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此段代码对应着我们自己写的代码中的static IEnumerator&lt;int&gt; TestIterator()  实例化一个状态为0的迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Nested Types 编译器生成的类，用来实现上面实例化的迭代器。</span></span><br><span class="line">    [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;<span class="title">TestIterator</span>&gt;<span class="title">d__0</span> : <span class="title">IEnumerator</span>&lt;<span class="title">int</span>&gt;, <span class="title">IEnumerator</span>, <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Fields 字段：state和current是默认出现的</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> &lt;&gt;<span class="number">1</span>__state;<span class="comment">//标识迭代器的状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> &lt;&gt;<span class="number">2</span>__current;<span class="comment">//追踪当前的值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> &lt;i&gt;<span class="number">5</span>__1;<span class="comment">//&lt;i&gt;5__1来自我们迭代器块中的局部变量i</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Methods 构造函数，初始化状态</span></span><br><span class="line">        [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">        <span class="keyword">public</span> &lt;TestIterator&gt;d__0(<span class="built_in">int</span> &lt;&gt;<span class="number">1</span>__state)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 几乎所有的逻辑在这里</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">this</span>.&lt;i&gt;<span class="number">5</span>__1 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">this</span>.&lt;i&gt;<span class="number">5</span>__1 &lt; <span class="number">10</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">this</span>.&lt;&gt;<span class="number">2</span>__current = <span class="keyword">this</span>.&lt;i&gt;<span class="number">5</span>__1;</span><br><span class="line">                        <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    Label_0046:</span><br><span class="line">                        <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">this</span>.&lt;i&gt;<span class="number">5</span>__1++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">goto</span> Label_0046;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">        <span class="keyword">void</span> IEnumerator.Reset()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IDisposable.Dispose()</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Properties</span></span><br><span class="line">        <span class="built_in">int</span> IEnumerator&lt;<span class="built_in">int</span>&gt;.Current</span><br><span class="line">        &#123;</span><br><span class="line">            [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.&lt;&gt;<span class="number">2</span>__current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">object</span> IEnumerator.Current</span><br><span class="line">        &#123;</span><br><span class="line">            [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.&lt;&gt;<span class="number">2</span>__current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这个迭代器的主要逻辑都集中在MoveNext()方法中。首先捋一遍代码：</p>
<ol>
<li>调用TestIterator()方法的结果仅仅是调用了&lt; TestIterator &gt;d_0（编译器生成的用来实现迭代器的类）的构造函数。而这个构造函数会设置迭代器的初始状态，此时的参数为0，而构造函数会将0赋值给记录迭代器状态的字段：this.&lt;&gt;1__ state = &lt;&gt;1__state;。注意，此时我们自己的代码并没有执行。</li>
<li>&lt; TestIterator&gt;d__0这个类实现了3个接口：IEnumerator&lt; int&gt;， IEnumerator， IDisposable。</li>
<li>IDisposable的实现十分重要。因为foreach语句会在它自己的finally代码块中调用实现了IDisposable接口的迭代器的Dispose方法。</li>
<li>&lt; TestIterator&gt;d_0类有3个字段：&lt;&gt;1_state，&lt;&gt;2_current， &lt; i&gt;5_1。其中，&lt;&gt;1_state私有字段标识迭代器的状态，&lt;&gt;2__current私有字段则追踪当前的值，而&lt; i&gt;5_1共有字段则是我们在迭代器块中定义的局部变量i。</li>
<li>MoveNext()方法的实现则依托与switch语句。根据状态机的状态，执行不同的代码。</li>
<li>在本例中Dispose方法什么都没有做。</li>
<li>在IEnumerator和IEnumerator&lt; int&gt;的实现中，Current都是单纯的返回&lt;&gt;2__current的值。</li>
</ol>
<p><strong>非常重要的几点：</strong></p>
<ul>
<li><strong>同一个函数内的其他代码（除了 yield return 语句）会被移到 MoveNext 中去，也就是说，每次 MoveNext 都会顺带执行同一个函数中 yield return 之前，之后 和两个 yield return 之间的代码。</strong></li>
<li> <strong>在协程方法（返回值类型为IEnumerator的方法）中使用 yield return 其实就是为了返回 IEnumerator对象，只有当这个对象的 MoveNext() 返回 false 时，即该 IEnumertator 的 Current 已经迭代到最后一个元素了，才会执行 yield return 后面的语句。也就是说， yield return 被会“翻译”为一个 IEnmerator 对象。</strong></li>
</ul>
<p>下面再来看看IEnumerable的内部实现：</p>
<p><strong>IEnumerable的内部实现</strong></p>
<p>也是先定义一个返回IEnumerable&lt; T&gt;的方法TestIterator()。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">TestIterator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，我们同样通过反编译，看看编译器又背着我们做了什么。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">TestIterator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> &lt;TestIterator&gt;d__0(<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;<span class="title">TestIterator</span>&gt;<span class="title">d__0</span> : <span class="title">IEnumerable</span>&lt;<span class="title">int</span>&gt;, <span class="title">IEnumerable</span>, <span class="title">IEnumerator</span>&lt;<span class="title">int</span>&gt;, <span class="title">IEnumerator</span>, <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Fields</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> &lt;&gt;<span class="number">2</span>__current;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> &lt;&gt;l__initialThreadId;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> &lt;count&gt;<span class="number">5</span>__1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;TestIterator&gt;d__0(<span class="built_in">int</span> &lt;&gt;<span class="number">1</span>__state)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;l__initialThreadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">this</span>.&lt;count&gt;<span class="number">5</span>__1 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">this</span>.&lt;count&gt;<span class="number">5</span>__1 &lt; <span class="number">10</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">this</span>.&lt;&gt;<span class="number">2</span>__current = <span class="keyword">this</span>.&lt;count&gt;<span class="number">5</span>__1;</span><br><span class="line">                        <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    Label_0046:</span><br><span class="line">                        <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">this</span>.&lt;count&gt;<span class="number">5</span>__1++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">goto</span> Label_0046;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IEnumerator&lt;<span class="built_in">int</span>&gt; IEnumerable&lt;<span class="built_in">int</span>&gt;.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((Thread.CurrentThread.ManagedThreadId == <span class="keyword">this</span>.&lt;&gt;l__initialThreadId) &amp;&amp; (<span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state == <span class="number">-2</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Test.&lt;TestIterator&gt;d__0(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ((IEnumerable&lt;Int32&gt;) <span class="keyword">this</span>).GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IEnumerator.Reset()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IDisposable.Dispose()</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> IEnumerator&lt;<span class="built_in">int</span>&gt;.Current</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.&lt;&gt;<span class="number">2</span>__current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">object</span> IEnumerator.Current</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.&lt;&gt;<span class="number">2</span>__current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到反编译出的代码，我们就很容易能对比出区别。</p>
<ol>
<li>&lt; TestIterator&gt;d__0类不仅实现了IEnumerable&lt; int&gt; 接口，而且还实现了IEnumerator&lt; int&gt;接口。</li>
<li>IEnumerator和IEnumerator&lt; int&gt;的实现都和上面一样。IEnumerator的Reset方法会抛出NotSupportedException异常，而IEnumerator和IEnumerator&lt; int&gt;的Current仍旧会返回&lt;&gt;2__current字段的值。</li>
<li>TestIterator()方法调用&lt; TestIterator&gt;d_0类的构造函数时，传入的参数由上面的0变成了-2：new &lt; TestIterator&gt;d__0(-2);。也就是说此时的初始状态是-2。</li>
<li>又多了一个新的私有字段&lt;&gt;l_initialThreadId，且会在&lt; TestIterator&gt;d__0的构造函数中被赋值，用来标识创建该实例的线程。</li>
<li>实现IEnumerable的GetEnumerator方法，在GetEnumerator方法中要么将状态置为-2，并返回this：this.&lt;&gt;1_state = 0；return this；要么就返回一个新的&lt; TestIterator&gt;d_0实例，且初始状态置为0：return new Test.&lt; TestIterator&gt;d__0(0);</li>
</ol>
<p>所以，从这些对比中我们能发现些什么吗？思考一下我们经常使用的一些用法，包括我在上一节中提供的小例子。不错，我们会创建一个IEnumerable<T>的实例，之后一些语句（例如foreach）会去调用GetEnumerator方法获取一个Enumerator<T>的实例，之后迭代数据，最终结束后释放掉迭代器的实例（这一步foreach会帮我们做）。</p>
<p>而分析IEnumerable的GetEnumerator方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator&lt;<span class="built_in">int</span>&gt; IEnumerable&lt;<span class="built_in">int</span>&gt;.GetEnumerator()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Thread.CurrentThread.ManagedThreadId == <span class="keyword">this</span>.&lt;&gt;l__initialThreadId) &amp;&amp; (<span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state == <span class="number">-2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Test.&lt;TestIterator&gt;d__0(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，-2这个状态，也就是此时的初始状态，表明了GetEnumerator()方法还没有执行。而0这个状态，则表明已经准备好了迭代，但是MoveNext()尚未调用过。</p>
<p>当在不同的线程上调用GetEnumerator方法或者是状态不是-2（证明已经不是初始状态了），则GetEnumerator方法会返回一个              &lt; TestIterator&gt;d__0类的新实例用来保存不同的状态。</p>
<h4 id="2-4-3-状态管理"><a href="#2-4-3-状态管理" class="headerlink" title="2.4.3 状态管理"></a>2.4.3 状态管理</h4><p>OK，我们深入了迭代器的内部，发现了原来它的实现主要依靠的是一个状态机。那么，下面就让我继续和大伙聊聊这个状态机是如何管理状态的。</p>
<p><strong>状态切换</strong></p>
<p>根据Ecma-334标准，我们可以知道迭代器有4种可能状态：</p>
<ol>
<li>before状态</li>
<li>running状态</li>
<li>suspended状态</li>
<li>after状态</li>
</ol>
<p>而其中before状态是作为初始状态出现的。</p>
<p>在我们讨论状态如何切换之前，我还要带领大家回想一下上面提到的，也就是在调用一个使用了迭代器块，返回类型为一个IEnumerator或 IEnumerable接口的方法时，这个方法并非立刻执行我们自己写的代码的。而是会创建一个编译器生成的类的实例，之后当调用MoveNext()方法时（当然如果方法的返回类型是IEnumerable，则要先调用GetEnumerator()方法），我们的代码才会开始执行，直到遇到第一个yield return语句或yield break语句，此时会返回一个布尔值来判断迭代是否结束。当下次再调用MoveNext()方法时，我们的方法会继续从上一个yield return语句处开始执行。</p>
<p>为了能够直观的观察状态的切换，我们来看下一个例子：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">TestStateChange</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;----我TestStateChange是第一行代码&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;----我是第一个yield return前的代码&quot;</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;----我是第一个yield return后的代码&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;----我是第二个yield return前的代码&quot;</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;----我是第二个yield return前的代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用TestStateChange&quot;</span>);</span><br><span class="line">        IEnumerable&lt;<span class="built_in">int</span>&gt; iteratorable = TestStateChange();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用GetEnumerator&quot;</span>);</span><br><span class="line">        IEnumerator&lt;<span class="built_in">int</span>&gt; iterator = iteratorable.GetEnumerator();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用MoveNext&quot;</span>);</span><br><span class="line">        <span class="built_in">bool</span> hasNext = iterator.MoveNext();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;是否有数据=&#123;0&#125;; Current=&#123;1&#125;&quot;</span>, hasNext, iterator.Current);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第二次调用MoveNext&quot;</span>);</span><br><span class="line">        hasNext = iterator.MoveNext();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;是否还有数据=&#123;0&#125;; Current=&#123;1&#125;&quot;</span>, hasNext, iterator.Current);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第三次调用MoveNext&quot;</span>);</span><br><span class="line">        hasNext = iterator.MoveNext();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;是否还有数据=&#123;0&#125;&quot;</span>, hasNext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">调用TestStateChange</span><br><span class="line">调用GetEnumerator</span><br><span class="line">调用MoveNext</span><br><span class="line">----我TestStateChange是第一行代码</span><br><span class="line">----我是第一个<span class="keyword">yield</span> <span class="keyword">return</span>前的代码</span><br><span class="line">是否有数据=True; Current=<span class="number">1</span></span><br><span class="line">第二次调用MoveNext</span><br><span class="line">----我是第一个<span class="keyword">yield</span> <span class="keyword">return</span>后的代码</span><br><span class="line">----我是第二个<span class="keyword">yield</span> <span class="keyword">return</span>前的代码</span><br><span class="line">是否还有数据=True; Current=<span class="number">2</span></span><br><span class="line">第三次调用MoveNext</span><br><span class="line">----我是第二个<span class="keyword">yield</span> <span class="keyword">return</span>前的代码</span><br><span class="line">是否还有数据=False</span><br></pre></td></tr></table></figure>

<p>可见，代码的执行顺序就是我刚刚总结的那样。那么我们将这段编译后的代码再反编译回C#，看看编译器到底是如何处理这里的状态切换的。</p>
<p>这里我们只关心两个方法，首先是GetEnumerator方法。其次是MoveNext方法。</p>
<p><strong>GetEnumerator方法</strong>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DebuggerHidden</span>]</span><br><span class="line">IEnumerator&lt;<span class="built_in">int</span>&gt; IEnumerable&lt;<span class="built_in">int</span>&gt;.GetEnumerator()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Environment.CurrentManagedThreadId == <span class="keyword">this</span>.&lt;&gt;l__initialThreadId) &amp;&amp; (<span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state == <span class="number">-2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Test.&lt;TestStateChange&gt;d__0(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>此时的初始状态是-2。</li>
<li>不过一旦调用GetEnumerator，则会将状态置为0。也就是状态从最初的-2，在调用过GetEnumerator方法后变成了0。</li>
</ol>
<p><strong>MoveNext方法</strong>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;----我TestStateChange是第一行代码&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;----我是第一个yield return前的代码&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">2</span>__current = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;----我是第一个yield return后的代码&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;----我是第二个yield return前的代码&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">2</span>__current = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">this</span>.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;----我是第二个yield return前的代码&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于第一次调用MoveNext方法发生在调用GetEnumerator方法之后，所以此时状态已经变成了0。</p>
<p>可以清晰的看到此时从0—&gt;1—&gt;2—&gt;-1这样的状态切换过程。而且还要注意，每个分支中，this.&lt;&gt;1_state都会首先被置为-1：this.&lt;&gt;1_state = -1。之后才会根据不同的阶段赋值不同的值。而这些不同的值也就用来标识代码从哪里恢复执行。</p>
<p><strong>各个状态总结</strong></p>
<p>让我们总结一下关于迭代器内部状态机的状态切换：</p>
<ul>
<li>-2状态：只有IEnumerable才有，表明在第一次调用GetEnumerator之前的状态。</li>
<li>-1状态：即上文中提到的C#语言标准中规定的Running状态，表明此时迭代器正在执行。当然，也会用于After状态，例如上例中的case 2中，this.&lt;&gt;1__state被赋值为-1，但是此时迭代结束了。</li>
<li>0状态：即上文中提到的Before状态，表明MoveNext()还一次都没有调用过。</li>
<li>正数（1，2，3…），主要用来标识从遇到yield之后，代码从哪里恢复执行。</li>
</ul>
<h3 id="2-5-协程的应用"><a href="#2-5-协程的应用" class="headerlink" title="2.5 协程的应用"></a>2.5 协程的应用</h3><p>当我们想要实现一个物体的逐渐淡化效果时，普通的方法是不行的，例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fade</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">float</span> f = <span class="number">1f</span>; f &gt;= <span class="number">0</span>; f -= <span class="number">0.1f</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        Color c = renderer.material.color;</span><br><span class="line">        c.a = f;</span><br><span class="line">        renderer.material.color = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数将完全在单个帧更新中执行。这种情况下，永远不会看到中间值，对象会立即消失。我们可以通过向 Update 函数添加此代码（此代码逐帧执行淡入淡出）来处理此类情况。但是，使用协程来执行此类任务通常会更方便。</p>
<p>协程就是一个返回迭代器的函数，能够暂停执行并将控制权返还给 Unity，然后在下一帧继续执行。在 C# 中，声明协程的方式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Fade</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">float</span> f = <span class="number">1f</span>; f &gt;= <span class="number">0</span>; f -= <span class="number">0.1f</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        Color c = renderer.material.color;</span><br><span class="line">        c.a = f;</span><br><span class="line">        renderer.material.color = c;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此协程本质上是一个用返回类型 IEnumerator 声明的函数，并在主体中的某个位置包含 yield return 语句。yield return 行是暂停执行并随后在下一帧恢复的点。要将协程设置为运行状态，必须使用 StartCoroutine函数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(<span class="string">&quot;f&quot;</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(<span class="string">&quot;Fade&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：使用StartCoroutine方法开始协程时传入的参数可以是协程的方法名StartCoroutine(Fade)；也可以是方法名的字符串形式StartCoroutine(“Fade”)。但是只有当参数是字符串形式传入时才能用StopCoroutine方法结束协程StopCoroutine(“Fade”)；。</p>
<p>默认情况下，协程将在执行 yield 后的帧上恢复，但也可以使用 WaitForSeconds 来引入时间延迟：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Fade</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">float</span> f = <span class="number">1f</span>; f &gt;= <span class="number">0</span>; f -= <span class="number">0.1f</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        Color c = renderer.material.color;</span><br><span class="line">        c.a = f;</span><br><span class="line">        renderer.material.color = c;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">.1</span>f</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、UI中RectTransform详解"><a href="#三、UI中RectTransform详解" class="headerlink" title="三、UI中RectTransform详解"></a>三、UI中RectTransform详解</h2><p>在做UI时需要在代码中调整控件的属性，比如位置、大小等，然而在NGUI中控制UI控件属性的是RectTransform这个组件(类)，它继承自Transform。为了更好的使用，下面就来深入学习一下RectTransform是怎么工作的。</p>
<h3 id="3-1-Pivot属性详解"><a href="#3-1-Pivot属性详解" class="headerlink" title="3.1 Pivot属性详解"></a>3.1 Pivot属性详解</h3><p>为了更好的理解，我在Unity中创建了两个UI控件：Plane控件，作为父对象；Image控件，作为子对象。</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624204822.png" alt="84177-cfa2c68fae729df8"></p>
<p>然后选中红框，来看看它的RectTransform组件的属性如下：</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624205124.png" alt="84177-b828e6e27cb3e3dc"></p>
<p>首先我们只看Pivot属性：</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624205159.png" alt="84177-bacb5a5d82197240"></p>
<p>Pivot我们可以暂时认为它是中心点，它是一个X,Y值范围是0到1的点，这个点的会在<strong>Anchor</strong>（锚点）计算位置的时候会使用到，下面用一张图来解释<strong>Pivot</strong>点的位置</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624205312.png" alt="84177-b27df7bbe9d3c829"></p>
<p>设置<strong>Pivot</strong>的坐标系如上图，(0,0)表示红框物体的左下角的点，(1,1)表示红框物体的右上角的点，而此时Pivot的值是(0.5,0.5)，表示此时的中心点是正中间。如下图：</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624205448.png" alt="QQ截图20210624205441"></p>
<h3 id="3-2-Anchor属性详解"><a href="#3-2-Anchor属性详解" class="headerlink" title="3.2 Anchor属性详解"></a>3.2 Anchor属性详解</h3><p>关于Anchor我们把它叫作锚点，但在Unity中Anchor应该称它为<strong>锚框</strong>更为合理，因为它是由两个锚点(Min，Max)组成的一个矩形，当然也可以组成一个点（两个点重合）</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624210120.png" alt="QQ截图20210624210100"></p>
<p>​                                                                                               重合时Anchor的值</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624210110.png" alt="QQ截图20210624205803"></p>
<p>​                                                                                                  不重合时Anchor的值</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624210353.png" alt="84177-f87b1d6124baa4cc"></p>
<p>这里的锚点是在image是Panel的子物体的情况下的，此锚点是父物体Panel上，用来约束image的。具体的约束方式下文阐述。</p>
<h3 id="3-3-Pivot和Anchor的结合"><a href="#3-3-Pivot和Anchor的结合" class="headerlink" title="3.3 Pivot和Anchor的结合"></a>3.3 Pivot和Anchor的结合</h3><h4 id="3-3-1-两个锚点重合时"><a href="#3-3-1-两个锚点重合时" class="headerlink" title="3.3.1 两个锚点重合时"></a>3.3.1 两个锚点重合时</h4><p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624210732.gif" alt="84177-0dc7e3bd42ec5e84"></p>
<p>我们从上图可以看出，不管我们怎么拖动黑框，改变他大小和位置，红框的Pivot点到Anchor点的距离是始终不变的，也就是说红框物体会参照锚点来实时调整自己的位置，使自己的Pivot点到锚点的距离始终保持一致，而且值得一提的是，在这种情况下，红框物体的<strong>RectTransform</strong>组件中的属性是<strong>Width</strong>和<strong>Height</strong>，这个属性在后面的情况中会发生变化。</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624210828.png" alt="84177-7549316d60d3a880"></p>
<p><strong>总结下第1种情况的特点就是：子物体的大小不会随着父物体的大小变化而变化，但是位置会根据Pivot点到Anchor点的距离一致的原则发生对应的变化</strong></p>
<h4 id="3-3-2-两个锚点不重合时，即锚框的情况"><a href="#3-3-2-两个锚点不重合时，即锚框的情况" class="headerlink" title="3.3.2 两个锚点不重合时，即锚框的情况"></a>3.3.2 两个锚点不重合时，即锚框的情况</h4><p>当两个锚点（AnchorMin和AnchorMax）不重合时，两点就会确定一个矩形，这个矩形就是我们的锚框，如下图中的绿框就是我们的锚框区域</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624211035.png" alt="84177-051144e96eaf0263"></p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624211506.png" alt="84177-ff69cbb3e32aadee"></p>
<p>此时我们再观察一下红框物体的<strong>RectTransform</strong>属性，发现属性分别变成了Left、Top、Right、Bottom。其中以锚框左下角的点为（0,0），(Left, Bottom)表示红框左下角的点，(Right, Top)表示红框右上角的点。如下图所示</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624211358.png" alt="84177-9921cfbf0183bc9a"></p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624211431.webp" alt="84177-3753b8f6c17205e1"></p>
<p>在黑框大小和位置变化的时候，Unity会保证红框的左下角到锚框的左下角距离不变，同时红框的右上角到锚框的右上角距离不变，来确定红框的相对位置和大小，看下图来感受一下变化：</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624211617.gif" alt="84177-920f57d425ee4257"></p>
<p><strong>总结下第2种情况的特点就是：子物体左下角的点到左下角锚点的距离和右上角的点到右上角锚点的距离不会随着父物体大小的改变而改变，但是这就导致了子物体的大小会随之变化。</strong></p>
<h3 id="3-4-anchoredPosition属性详解"><a href="#3-4-anchoredPosition属性详解" class="headerlink" title="3.4 anchoredPosition属性详解"></a>3.4 anchoredPosition属性详解</h3><p>anchoredPosition根据名字的含义，我们大概可以猜出他是根据anchor锚点得出来个一个位置属性，他本身是一个点，如果在AnchorMin和AnchorMax是重合的情况下，anchoredPosition就是表示锚点到Pivot的位置，如下图所示：</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624212015.png" alt="84177-ef0d5ae1d309d681"></p>
<p>但是如果AnchorMin和AnchorMax不重合的时候，anchoredPosition就比较复杂了，在这种情况下，Unity会根据Pivot、AnchorMin和AnchorMax计算出一个锚点，然后在通过Pivot和锚点来得出anchoredPosition的位置，关于如何计算规则这里就不做阐述了。</p>
<h3 id="3-5-offsetMin和offsetMax详解"><a href="#3-5-offsetMin和offsetMax详解" class="headerlink" title="3.5 offsetMin和offsetMax详解"></a>3.5 offsetMin和offsetMax详解</h3><p>offsetMin和offsetMax这两个属性比较好理解，其中offsetMin表示物体（本文中的红框）左下角相对AnchorMin的偏移，offsetMax表示物体右上角相对AnchorMax的偏移。</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624212135.png" alt="84177-6feb68ae67ceaae8"></p>
<h3 id="3-6-sizeDelta详解"><a href="#3-6-sizeDelta详解" class="headerlink" title="3.6 sizeDelta详解"></a>3.6 sizeDelta详解</h3><p>sizeDelta就是offsetMax - offsetMin的差，即物体左下角到右上角的变量，如下图所示：</p>
<p><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210624212217.png" alt="84177-d3b70ac4ab07d1bd"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">刘一钦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/03/01/UnityKnowledge/">http://example.com/2021/03/01/UnityKnowledge/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">刘一钦的成长之路</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9/">Unity扩展知识点</a></div><div class="post_share"><div class="social-share" data-image="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210803144953.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/03/07/C-sharp/"><img class="prev-cover" src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210731140002.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C#语言入门详解</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">刘一钦</div><div class="author-info__description">眼前已是星辰大海，又何必刻舟求剑</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">技术，源于积累</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">Unity扩展知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E4%B8%8E%E5%B9%BF%E6%92%AD%E9%AB%98%E5%BA%A6%E8%A7%A3%E8%80%A6%E5%90%88"><span class="toc-text">一、使用事件的监听与广播高度解耦合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%9B%91%E5%90%AC%E4%B8%8E%E5%B9%BF%E6%92%AD%E5%9F%BA%E4%BA%8E%E7%9A%84%E4%B8%89%E4%B8%AA%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-text">1.1 监听与广播基于的三个脚本文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%96%87%E4%BB%B6%E5%AF%B9%E7%9B%91%E5%90%AC%E4%B8%8E%E5%B9%BF%E6%92%AD%E8%84%9A%E6%9C%AC%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-text">1.2 文件对监听与广播脚本的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%AD%A4%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%A9%E4%B8%8E%E5%BC%8A"><span class="toc-text">1.3 此方法的利与弊</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="toc-text">二、协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Time%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">2.1  Time类中的各种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Time-deltaTime"><span class="toc-text">Time.deltaTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Time-time"><span class="toc-text">Time.time</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-yield%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.2 yield关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-yield-return%E5%AE%9E%E4%BE%8B"><span class="toc-text">2.2.1 yield return实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-yield-return%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">2.2.2 yield return的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-WaitForSeconds%E6%96%B9%E6%B3%95"><span class="toc-text">2.2.3 WaitForSeconds方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-foreach%E5%8E%9F%E7%90%86"><span class="toc-text">2.3 foreach原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">2.4 迭代器原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E4%BA%86%E8%A7%A3"><span class="toc-text">2.4.1 迭代器初了解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">2.4.2 状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-text">2.4.3 状态管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">2.5 协程的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81UI%E4%B8%ADRectTransform%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、UI中RectTransform详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Pivot%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.1 Pivot属性详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Anchor%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.2 Anchor属性详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Pivot%E5%92%8CAnchor%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-text">3.3 Pivot和Anchor的结合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E4%B8%A4%E4%B8%AA%E9%94%9A%E7%82%B9%E9%87%8D%E5%90%88%E6%97%B6"><span class="toc-text">3.3.1 两个锚点重合时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E4%B8%A4%E4%B8%AA%E9%94%9A%E7%82%B9%E4%B8%8D%E9%87%8D%E5%90%88%E6%97%B6%EF%BC%8C%E5%8D%B3%E9%94%9A%E6%A1%86%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">3.3.2 两个锚点不重合时，即锚框的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-anchoredPosition%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.4 anchoredPosition属性详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-offsetMin%E5%92%8CoffsetMax%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.5 offsetMin和offsetMax详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-sizeDelta%E8%AF%A6%E8%A7%A3"><span class="toc-text">3.6 sizeDelta详解</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/31/C-Sharp_API/" title="C#与Unity中的常用API"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_2/20210307151121.png!webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#与Unity中的常用API"/></a><div class="content"><a class="title" href="/2021/07/31/C-Sharp_API/" title="C#与Unity中的常用API">C#与Unity中的常用API</a><time datetime="2021-07-30T16:00:00.000Z" title="发表于 2021-07-31 00:00:00">2021-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/26/Unity3DPhysicalSystem/" title="3D物理系统初学习"><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210803143607.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3D物理系统初学习"/></a><div class="content"><a class="title" href="/2021/07/26/Unity3DPhysicalSystem/" title="3D物理系统初学习">3D物理系统初学习</a><time datetime="2021-07-25T16:00:00.000Z" title="发表于 2021-07-26 00:00:00">2021-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/20/Json/" title="Json文件的解析"><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210803140500.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Json文件的解析"/></a><div class="content"><a class="title" href="/2021/07/20/Json/" title="Json文件的解析">Json文件的解析</a><time datetime="2021-07-19T16:00:00.000Z" title="发表于 2021-07-20 00:00:00">2021-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/15/DataStructureCode/" title="数据结构代码详解"><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210803141844.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构代码详解"/></a><div class="content"><a class="title" href="/2021/07/15/DataStructureCode/" title="数据结构代码详解">数据结构代码详解</a><time datetime="2021-07-14T16:00:00.000Z" title="发表于 2021-07-15 00:00:00">2021-07-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/01/DesignPattern/" title="设计模式"><img src="https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210803110214.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/2021/07/01/DesignPattern/" title="设计模式">设计模式</a><time datetime="2021-06-30T16:00:00.000Z" title="发表于 2021-07-01 00:00:00">2021-07-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://study-liu.oss-cn-shanghai.aliyuncs.com/study/20210802151513.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 刘一钦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>